{"version":3,"file":"DataStore.js","sourceRoot":"","sources":["../src/DataStore.ts"],"names":[],"mappings":"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","sourcesContent":["import { GatewayOpcodes } from 'discord-api-types/v9';\nimport { AudioPlayer } from './audio';\nimport { VoiceConnection } from './VoiceConnection';\n\nexport interface JoinConfig {\n\tguildId: string;\n\tchannelId: string | null;\n\tselfDeaf: boolean;\n\tselfMute: boolean;\n\tgroup: string;\n}\n\n/**\n * Sends a voice state update to the main websocket shard of a guild, to indicate joining/leaving/moving across\n * voice channels.\n *\n * @param config - The configuration to use when joining the voice channel\n */\nexport function createJoinVoiceChannelPayload(config: JoinConfig) {\n\treturn {\n\t\top: GatewayOpcodes.VoiceStateUpdate,\n\t\td: {\n\t\t\tguild_id: config.guildId,\n\t\t\tchannel_id: config.channelId,\n\t\t\tself_deaf: config.selfDeaf,\n\t\t\tself_mute: config.selfMute,\n\t\t},\n\t};\n}\n\n// Voice Connections\nconst groups: Map<string, Map<string, VoiceConnection>> = new Map();\ngroups.set('default', new Map());\n\nfunction getOrCreateGroup(group: string) {\n\tconst existing = groups.get(group);\n\tif (existing) return existing;\n\tconst map = new Map();\n\tgroups.set(group, map);\n\treturn map;\n}\n\n/**\n * Retrieves the map of group names to maps of voice connections. By default, all voice connections\n * are created under the 'default' group.\n * @returns The group map\n */\nexport function getGroups() {\n\treturn groups;\n}\n\nexport function getVoiceConnections(group?: 'default'): Map<string, VoiceConnection>;\nexport function getVoiceConnections(group: string): Map<string, VoiceConnection> | undefined;\n/**\n * Retrieves all the voice connections under the given group name. Defaults to the 'default' group.\n * @param group - The group to look up\n * @returns The map of voice connections\n */\nexport function getVoiceConnections(group = 'default') {\n\treturn groups.get(group);\n}\n\n/**\n * Finds a voice connection with the given guild ID and group. Defaults to the 'default' group.\n * @param guildId - The guild ID of the voice connection\n * @param group - the group that the voice connection was registered with\n * @returns The voice connection, if it exists\n */\nexport function getVoiceConnection(guildId: string, group = 'default') {\n\treturn getVoiceConnections(group)?.get(guildId);\n}\n\nexport function untrackVoiceConnection(voiceConnection: VoiceConnection) {\n\treturn getVoiceConnections(voiceConnection.joinConfig.group)?.delete(voiceConnection.joinConfig.guildId);\n}\n\nexport function trackVoiceConnection(voiceConnection: VoiceConnection) {\n\treturn getOrCreateGroup(voiceConnection.joinConfig.group).set(voiceConnection.joinConfig.guildId, voiceConnection);\n}\n\n// Audio Players\n\n// Each audio packet is 20ms long\nconst FRAME_LENGTH = 20;\n\nlet audioCycleInterval: NodeJS.Timeout | undefined;\nlet nextTime = -1;\n\n/**\n * A list of created audio players that are still active and haven't been destroyed.\n */\nconst audioPlayers: AudioPlayer[] = [];\n\n/**\n * Called roughly every 20 milliseconds. Dispatches audio from all players, and then gets the players to prepare\n * the next audio frame.\n */\nfunction audioCycleStep() {\n\tif (nextTime === -1) return;\n\n\tnextTime += FRAME_LENGTH;\n\tconst available = audioPlayers.filter((player) => player.checkPlayable());\n\n\t// eslint-disable-next-line @typescript-eslint/dot-notation\n\tavailable.forEach((player) => player['_stepDispatch']());\n\n\tprepareNextAudioFrame(available);\n}\n\n/**\n * Recursively gets the players that have been passed as parameters to prepare audio frames that can be played.\n * at the start of the next cycle.\n */\nfunction prepareNextAudioFrame(players: AudioPlayer[]) {\n\tconst nextPlayer = players.shift();\n\n\tif (!nextPlayer) {\n\t\tif (nextTime !== -1) {\n\t\t\taudioCycleInterval = setTimeout(() => audioCycleStep(), nextTime - Date.now());\n\t\t}\n\t\treturn;\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/dot-notation\n\tnextPlayer['_stepPrepare']();\n\n\t// setImmediate to avoid long audio player chains blocking other scheduled tasks\n\tsetImmediate(() => prepareNextAudioFrame(players));\n}\n\n/**\n * Checks whether or not the given audio player is being driven by the data store clock.\n *\n * @param target - The target to test for\n * @returns true if it is being tracked, false otherwise\n */\nexport function hasAudioPlayer(target: AudioPlayer) {\n\treturn audioPlayers.includes(target);\n}\n\n/**\n * Adds an audio player to the data store tracking list, if it isn't already there.\n *\n * @param player - The player to track\n */\nexport function addAudioPlayer(player: AudioPlayer) {\n\tif (hasAudioPlayer(player)) return player;\n\taudioPlayers.push(player);\n\tif (audioPlayers.length === 1) {\n\t\tnextTime = Date.now();\n\t\tsetImmediate(() => audioCycleStep());\n\t}\n\treturn player;\n}\n\n/**\n * Removes an audio player from the data store tracking list, if it is present there.\n */\nexport function deleteAudioPlayer(player: AudioPlayer) {\n\tconst index = audioPlayers.indexOf(player);\n\tif (index === -1) return;\n\taudioPlayers.splice(index, 1);\n\tif (audioPlayers.length === 0) {\n\t\tnextTime = -1;\n\t\tif (typeof audioCycleInterval !== 'undefined') clearTimeout(audioCycleInterval);\n\t}\n}\n"]}