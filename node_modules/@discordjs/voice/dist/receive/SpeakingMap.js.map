{"version":3,"file":"SpeakingMap.js","sourceRoot":"","sources":["../../src/receive/SpeakingMap.ts"],"names":[],"mappings":";;;AAAA,2DAAkD;AAiBlD;;GAEG;AACH,MAAa,WAAY,SAAQ,iCAA+B;IAY/D;QACC,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG,EAAE,CAAC;QACvB,IAAI,CAAC,gBAAgB,GAAG,IAAI,GAAG,EAAE,CAAC;IACnC,CAAC;IAEM,QAAQ,CAAC,MAAc;QAC7B,MAAM,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAClD,IAAI,OAAO,EAAE;YACZ,YAAY,CAAC,OAAO,CAAC,CAAC;SACtB;aAAM;YACN,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;YACnC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;SAC3B;QACD,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IAC3B,CAAC;IAEO,YAAY,CAAC,MAAc;QAClC,IAAI,CAAC,gBAAgB,CAAC,GAAG,CACxB,MAAM,EACN,UAAU,CAAC,GAAG,EAAE;YACf,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;YACzB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YACrC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAC3B,CAAC,EAAE,WAAW,CAAC,KAAK,CAAC,CACrB,CAAC;IACH,CAAC;;AAtCF,kCAuCC;AAtCA;;GAEG;AACoB,iBAAK,GAAG,GAAG,CAAC","sourcesContent":["import { TypedEmitter } from 'tiny-typed-emitter';\nimport { Awaited } from '../util/util';\n\n/**\n * The events that a SpeakingMap can emit\n */\nexport interface SpeakingMapEvents {\n\t/**\n\t * Emitted when a user starts speaking.\n\t */\n\tstart: (userId: string) => Awaited<void>;\n\t/**\n\t * Emitted when a user stops speaking.\n\t */\n\tend: (userId: string) => Awaited<void>;\n}\n\n/**\n * Tracks the speaking states of users in a voice channel.\n */\nexport class SpeakingMap extends TypedEmitter<SpeakingMapEvents> {\n\t/**\n\t * The delay after a packet is received from a user until they're marked as not speaking anymore.\n\t */\n\tpublic static readonly DELAY = 100;\n\t/**\n\t * The currently speaking users, mapped to the milliseconds since UNIX epoch at which they started speaking.\n\t */\n\tpublic readonly users: Map<string, number>;\n\n\tprivate readonly speakingTimeouts: Map<string, NodeJS.Timeout>;\n\n\tpublic constructor() {\n\t\tsuper();\n\t\tthis.users = new Map();\n\t\tthis.speakingTimeouts = new Map();\n\t}\n\n\tpublic onPacket(userId: string) {\n\t\tconst timeout = this.speakingTimeouts.get(userId);\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t} else {\n\t\t\tthis.users.set(userId, Date.now());\n\t\t\tthis.emit('start', userId);\n\t\t}\n\t\tthis.startTimeout(userId);\n\t}\n\n\tprivate startTimeout(userId: string) {\n\t\tthis.speakingTimeouts.set(\n\t\t\tuserId,\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.emit('end', userId);\n\t\t\t\tthis.speakingTimeouts.delete(userId);\n\t\t\t\tthis.users.delete(userId);\n\t\t\t}, SpeakingMap.DELAY),\n\t\t);\n\t}\n}\n"]}