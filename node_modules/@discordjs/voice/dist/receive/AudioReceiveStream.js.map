{"version":3,"file":"AudioReceiveStream.js","sourceRoot":"","sources":["../../src/receive/AudioReceiveStream.ts"],"names":[],"mappings":";;;AAAA,mCAAmD;AACnD,sDAAqD;AAErD;;GAEG;AACH,IAAY,eAaX;AAbD,WAAY,eAAe;IAC1B;;OAEG;IACH,yDAAM,CAAA;IACN;;OAEG;IACH,qEAAY,CAAA;IACZ;;OAEG;IACH,2EAAe,CAAA;AAChB,CAAC,EAbW,eAAe,GAAf,uBAAe,KAAf,uBAAe,QAa1B;AAeD,SAAgB,sCAAsC;IACrD,OAAO;QACN,GAAG,EAAE;YACJ,QAAQ,EAAE,eAAe,CAAC,MAAM;SAChC;KACD,CAAC;AACH,CAAC;AAND,wFAMC;AAED;;;GAGG;AACH,MAAa,kBAAmB,SAAQ,iBAAQ;IAQ/C,YAAmB,EAAE,GAAG,EAAE,GAAG,OAAO,EAA6B;QAChE,KAAK,CAAC;YACL,GAAG,OAAO;YACV,UAAU,EAAE,IAAI;SAChB,CAAC,CAAC;QAEH,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;IAChB,CAAC;IAEM,IAAI,CAAC,MAAqB;QAChC,IAAI,MAAM,EAAE;YACX,IACC,IAAI,CAAC,GAAG,CAAC,QAAQ,KAAK,eAAe,CAAC,eAAe;gBACrD,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,KAAK,eAAe,CAAC,YAAY;oBAClD,CAAC,MAAM,CAAC,OAAO,CAAC,2BAAa,CAAC,KAAK,CAAC,IAAI,OAAO,IAAI,CAAC,UAAU,KAAK,WAAW,CAAC,CAAC,EAChF;gBACD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;aAC/B;SACD;QAED,OAAO,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC3B,CAAC;IAEO,eAAe,CAAC,GAAuC;QAC9D,IAAI,IAAI,CAAC,UAAU,EAAE;YACpB,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SAC9B;QACD,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC;IACnE,CAAC;IAED,gEAAgE;IACzD,KAAK,KAAI,CAAC;CACjB;AAxCD,gDAwCC","sourcesContent":["import { Readable, ReadableOptions } from 'stream';\nimport { SILENCE_FRAME } from '../audio/AudioPlayer';\n\n/**\n * The different behaviors an audio receive stream can have for deciding when to end.\n */\nexport enum EndBehaviorType {\n\t/**\n\t * The stream will only end when manually destroyed.\n\t */\n\tManual,\n\t/**\n\t * The stream will end after a given time period of silence/no audio packets.\n\t */\n\tAfterSilence,\n\t/**\n\t * The stream will end after a given time period of no audio packets.\n\t */\n\tAfterInactivity,\n}\n\nexport type EndBehavior =\n\t| {\n\t\t\tbehavior: EndBehaviorType.Manual;\n\t  }\n\t| {\n\t\t\tbehavior: EndBehaviorType.AfterSilence | EndBehaviorType.AfterInactivity;\n\t\t\tduration: number;\n\t  };\n\nexport interface AudioReceiveStreamOptions extends ReadableOptions {\n\tend: EndBehavior;\n}\n\nexport function createDefaultAudioReceiveStreamOptions(): AudioReceiveStreamOptions {\n\treturn {\n\t\tend: {\n\t\t\tbehavior: EndBehaviorType.Manual,\n\t\t},\n\t};\n}\n\n/**\n * A readable stream of Opus packets received from a specific entity\n * in a Discord voice connection.\n */\nexport class AudioReceiveStream extends Readable {\n\t/**\n\t * The end behavior of the receive stream.\n\t */\n\tpublic readonly end: EndBehavior;\n\n\tprivate endTimeout?: NodeJS.Timeout;\n\n\tpublic constructor({ end, ...options }: AudioReceiveStreamOptions) {\n\t\tsuper({\n\t\t\t...options,\n\t\t\tobjectMode: true,\n\t\t});\n\n\t\tthis.end = end;\n\t}\n\n\tpublic push(buffer: Buffer | null) {\n\t\tif (buffer) {\n\t\t\tif (\n\t\t\t\tthis.end.behavior === EndBehaviorType.AfterInactivity ||\n\t\t\t\t(this.end.behavior === EndBehaviorType.AfterSilence &&\n\t\t\t\t\t(buffer.compare(SILENCE_FRAME) !== 0 || typeof this.endTimeout === 'undefined'))\n\t\t\t) {\n\t\t\t\tthis.renewEndTimeout(this.end);\n\t\t\t}\n\t\t}\n\n\t\treturn super.push(buffer);\n\t}\n\n\tprivate renewEndTimeout(end: EndBehavior & { duration: number }) {\n\t\tif (this.endTimeout) {\n\t\t\tclearTimeout(this.endTimeout);\n\t\t}\n\t\tthis.endTimeout = setTimeout(() => this.push(null), end.duration);\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\tpublic _read() {}\n}\n"]}