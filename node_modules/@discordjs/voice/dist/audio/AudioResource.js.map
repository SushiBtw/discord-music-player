{"version":3,"file":"AudioResource.js","sourceRoot":"","sources":["../../src/audio/AudioResource.ts"],"names":[],"mappings":"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","sourcesContent":["import { Edge, findPipeline, StreamType, TransformerType } from './TransformerGraph';\nimport { pipeline, Readable } from 'stream';\nimport { noop } from '../util/util';\nimport { VolumeTransformer, opus } from 'prism-media';\nimport { AudioPlayer, SILENCE_FRAME } from './AudioPlayer';\n\n/**\n * Options that are set when creating a new audio resource.\n *\n * @template T - the type for the metadata (if any) of the audio resource.\n */\ninterface CreateAudioResourceOptions<T> {\n\t/**\n\t * The type of the input stream. Defaults to `StreamType.Arbitrary`.\n\t */\n\tinputType?: StreamType;\n\n\t/**\n\t * Optional metadata that can be attached to the resource (e.g. track title, random ID).\n\t * This is useful for identification purposes when the resource is passed around in events.\n\t * See {@link AudioResource.metadata}\n\t */\n\tmetadata?: T;\n\n\t/**\n\t * Whether or not inline volume should be enabled. If enabled, you will be able to change the volume\n\t * of the stream on-the-fly. However, this also increases the performance cost of playback. Defaults to `false`.\n\t */\n\tinlineVolume?: boolean;\n\n\t/**\n\t * The number of silence frames to append to the end of the resource's audio stream, to prevent interpolation glitches.\n\t * Defaults to 5.\n\t */\n\tsilencePaddingFrames?: number;\n}\n\n/**\n * Represents an audio resource that can be played by an audio player.\n *\n * @template T - the type for the metadata (if any) of the audio resource.\n */\nexport class AudioResource<T = unknown> {\n\t/**\n\t * An object-mode Readable stream that emits Opus packets. This is what is played by audio players.\n\t */\n\tpublic readonly playStream: Readable;\n\n\t/**\n\t * The pipeline used to convert the input stream into a playable format. For example, this may\n\t * contain an FFmpeg component for arbitrary inputs, and it may contain a VolumeTransformer component\n\t * for resources with inline volume transformation enabled.\n\t */\n\tpublic readonly edges: readonly Edge[];\n\n\t/**\n\t * Optional metadata that can be used to identify the resource.\n\t */\n\tpublic metadata: T;\n\n\t/**\n\t * If the resource was created with inline volume transformation enabled, then this will be a\n\t * prism-media VolumeTransformer. You can use this to alter the volume of the stream.\n\t */\n\tpublic readonly volume?: VolumeTransformer;\n\n\t/**\n\t * If using an Opus encoder to create this audio resource, then this will be a prism-media opus.Encoder.\n\t * You can use this to control settings such as bitrate, FEC, PLP.\n\t */\n\tpublic readonly encoder?: opus.Encoder;\n\n\t/**\n\t * The audio player that the resource is subscribed to, if any.\n\t */\n\tpublic audioPlayer?: AudioPlayer;\n\n\t/**\n\t * The playback duration of this audio resource, given in milliseconds.\n\t */\n\tpublic playbackDuration = 0;\n\n\t/**\n\t * Whether or not the stream for this resource has started (data has become readable)\n\t */\n\tpublic started = false;\n\n\t/**\n\t * The number of silence frames to append to the end of the resource's audio stream, to prevent interpolation glitches.\n\t */\n\tpublic readonly silencePaddingFrames: number;\n\n\t/**\n\t * The number of remaining silence frames to play. If -1, the frames have not yet started playing.\n\t */\n\tpublic silenceRemaining = -1;\n\n\tpublic constructor(edges: readonly Edge[], streams: readonly Readable[], metadata: T, silencePaddingFrames: number) {\n\t\tthis.edges = edges;\n\t\tthis.playStream = streams.length > 1 ? (pipeline(streams, noop) as any as Readable) : streams[0];\n\t\tthis.metadata = metadata;\n\t\tthis.silencePaddingFrames = silencePaddingFrames;\n\n\t\tfor (const stream of streams) {\n\t\t\tif (stream instanceof VolumeTransformer) {\n\t\t\t\tthis.volume = stream;\n\t\t\t} else if (stream instanceof opus.Encoder) {\n\t\t\t\tthis.encoder = stream;\n\t\t\t}\n\t\t}\n\n\t\tthis.playStream.once('readable', () => (this.started = true));\n\t}\n\n\t/**\n\t * Whether this resource is readable. If the underlying resource is no longer readable, this will still return true\n\t * while there are silence padding frames left to play.\n\t */\n\tpublic get readable() {\n\t\tif (this.silenceRemaining === 0) return false;\n\t\tconst real = this.playStream.readable;\n\t\tif (!real) {\n\t\t\tif (this.silenceRemaining === -1) this.silenceRemaining = this.silencePaddingFrames;\n\t\t\treturn this.silenceRemaining !== 0;\n\t\t}\n\t\treturn real;\n\t}\n\n\t/**\n\t * Whether this resource has ended or not.\n\t */\n\tpublic get ended() {\n\t\treturn this.playStream.readableEnded || this.playStream.destroyed || this.silenceRemaining === 0;\n\t}\n\n\t/**\n\t * Attempts to read an Opus packet from the audio resource. If a packet is available, the playbackDuration\n\t * is incremented.\n\t * @internal\n\t * @remarks\n\t * It is advisable to check that the playStream is readable before calling this method. While no runtime\n\t * errors will be thrown, you should check that the resource is still available before attempting to\n\t * read from it.\n\t */\n\tpublic read(): Buffer | null {\n\t\tif (this.silenceRemaining === 0) {\n\t\t\treturn null;\n\t\t} else if (this.silenceRemaining > 0) {\n\t\t\tthis.silenceRemaining--;\n\t\t\treturn SILENCE_FRAME;\n\t\t}\n\t\tconst packet: Buffer | null = this.playStream.read();\n\t\tif (packet) {\n\t\t\tthis.playbackDuration += 20;\n\t\t}\n\t\treturn packet;\n\t}\n}\n\n/**\n * Ensures that a path contains at least one volume transforming component\n *\n * @param path - The path to validate constraints on\n */\nexport const VOLUME_CONSTRAINT = (path: Edge[]) => path.some((edge) => edge.type === TransformerType.InlineVolume);\n\nexport const NO_CONSTRAINT = () => true;\n\n/**\n * Tries to infer the type of a stream to aid with transcoder pipelining.\n *\n * @param stream - The stream to infer the type of\n */\nexport function inferStreamType(stream: Readable): {\n\tstreamType: StreamType;\n\thasVolume: boolean;\n} {\n\tif (stream instanceof opus.Encoder) {\n\t\treturn { streamType: StreamType.Opus, hasVolume: false };\n\t} else if (stream instanceof opus.Decoder) {\n\t\treturn { streamType: StreamType.Raw, hasVolume: false };\n\t} else if (stream instanceof VolumeTransformer) {\n\t\treturn { streamType: StreamType.Raw, hasVolume: true };\n\t} else if (stream instanceof opus.OggDemuxer) {\n\t\treturn { streamType: StreamType.Opus, hasVolume: false };\n\t} else if (stream instanceof opus.WebmDemuxer) {\n\t\treturn { streamType: StreamType.Opus, hasVolume: false };\n\t}\n\treturn { streamType: StreamType.Arbitrary, hasVolume: false };\n}\n\nexport function createAudioResource<T>(\n\tinput: string | Readable,\n\toptions: CreateAudioResourceOptions<T> &\n\t\tPick<\n\t\t\tT extends null | undefined ? CreateAudioResourceOptions<T> : Required<CreateAudioResourceOptions<T>>,\n\t\t\t'metadata'\n\t\t>,\n): AudioResource<T extends null | undefined ? null : T>;\n\nexport function createAudioResource<T extends null | undefined>(\n\tinput: string | Readable,\n\toptions?: Omit<CreateAudioResourceOptions<T>, 'metadata'>,\n): AudioResource<null>;\n\n/**\n * Creates an audio resource that can be played be audio players.\n *\n * @remarks\n * If the input is given as a string, then the inputType option will be overridden and FFmpeg will be used.\n *\n * If the input is not in the correct format, then a pipeline of transcoders and transformers will be created\n * to ensure that the resultant stream is in the correct format for playback. This could involve using FFmpeg,\n * Opus transcoders, and Ogg/WebM demuxers.\n *\n * @param input - The resource to play.\n * @param options - Configurable options for creating the resource.\n *\n * @template T - the type for the metadata (if any) of the audio resource.\n */\nexport function createAudioResource<T>(\n\tinput: string | Readable,\n\toptions: CreateAudioResourceOptions<T> = {},\n): AudioResource<T> {\n\tlet inputType = options.inputType;\n\tlet needsInlineVolume = Boolean(options.inlineVolume);\n\n\t// string inputs can only be used with FFmpeg\n\tif (typeof input === 'string') {\n\t\tinputType = StreamType.Arbitrary;\n\t} else if (typeof inputType === 'undefined') {\n\t\tconst analysis = inferStreamType(input);\n\t\tinputType = analysis.streamType;\n\t\tneedsInlineVolume = needsInlineVolume && !analysis.hasVolume;\n\t}\n\n\tconst transformerPipeline = findPipeline(inputType, needsInlineVolume ? VOLUME_CONSTRAINT : NO_CONSTRAINT);\n\n\tif (transformerPipeline.length === 0) {\n\t\tif (typeof input === 'string') throw new Error(`Invalid pipeline constructed for string resource '${input}'`);\n\t\t// No adjustments required\n\t\treturn new AudioResource<T>([], [input], (options.metadata ?? null) as T, options.silencePaddingFrames ?? 5);\n\t}\n\tconst streams = transformerPipeline.map((edge) => edge.transformer(input));\n\tif (typeof input !== 'string') streams.unshift(input);\n\n\treturn new AudioResource<T>(\n\t\ttransformerPipeline,\n\t\tstreams,\n\t\t(options.metadata ?? null) as T,\n\t\toptions.silencePaddingFrames ?? 5,\n\t);\n}\n"]}