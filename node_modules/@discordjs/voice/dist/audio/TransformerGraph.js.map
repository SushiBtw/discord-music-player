{"version":3,"file":"TransformerGraph.js","sourceRoot":"","sources":["../../src/audio/TransformerGraph.ts"],"names":[],"mappings":"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","sourcesContent":["import { Readable } from 'stream';\nimport * as prism from 'prism-media';\n\n/*\n\tThis module creates a Transformer Graph to figure out what the most efficient way\n\tof transforming the input stream into something playable would be.\n*/\n\nconst FFMPEG_PCM_ARGUMENTS = ['-analyzeduration', '0', '-loglevel', '0', '-f', 's16le', '-ar', '48000', '-ac', '2'];\nconst FFMPEG_OPUS_ARGUMENTS = [\n\t'-analyzeduration',\n\t'0',\n\t'-loglevel',\n\t'0',\n\t'-acodec',\n\t'libopus',\n\t'-f',\n\t'opus',\n\t'-ar',\n\t'48000',\n\t'-ac',\n\t'2',\n];\n\n/**\n * The different types of stream that can exist within the pipeline\n *\n * @remarks\n * - `Arbitrary` - the type of the stream at this point is unknown.\n *\n * - `Raw` - the stream at this point is s16le PCM.\n *\n * - `OggOpus` - the stream at this point is Opus audio encoded in an Ogg wrapper.\n *\n * - `WebmOpus` - the stream at this point is Opus audio encoded in a WebM wrapper.\n *\n * - `Opus` - the stream at this point is Opus audio, and the stream is in object-mode. This is ready to play.\n */\nexport enum StreamType {\n\tArbitrary = 'arbitrary',\n\tRaw = 'raw',\n\tOggOpus = 'ogg/opus',\n\tWebmOpus = 'webm/opus',\n\tOpus = 'opus',\n}\n\n/**\n * The different types of transformers that can exist within the pipeline\n */\nexport enum TransformerType {\n\tFFmpegPCM = 'ffmpeg pcm',\n\tFFmpegOgg = 'ffmpeg ogg',\n\tOpusEncoder = 'opus encoder',\n\tOpusDecoder = 'opus decoder',\n\tOggOpusDemuxer = 'ogg/opus demuxer',\n\tWebmOpusDemuxer = 'webm/opus demuxer',\n\tInlineVolume = 'volume transformer',\n}\n\n/**\n * Represents a pathway from one stream type to another using a transformer\n */\nexport interface Edge {\n\tfrom: Node;\n\tto: Node;\n\tcost: number;\n\ttransformer: (input: string | Readable) => Readable;\n\ttype: TransformerType;\n}\n\n/**\n * Represents a type of stream within the graph, e.g. an Opus stream, or a stream of raw audio.\n */\nexport class Node {\n\t/**\n\t * The outbound edges from this node\n\t */\n\tpublic readonly edges: Edge[] = [];\n\n\t/**\n\t * The type of stream for this node\n\t */\n\tpublic readonly type: StreamType;\n\n\tpublic constructor(type: StreamType) {\n\t\tthis.type = type;\n\t}\n\n\t/**\n\t * Creates an outbound edge from this node\n\t *\n\t * @param edge - The edge to create\n\t */\n\tpublic addEdge(edge: Omit<Edge, 'from'>) {\n\t\tthis.edges.push({ ...edge, from: this });\n\t}\n}\n\n// Create a node for each stream type\nconst NODES = new Map<StreamType, Node>();\nfor (const streamType of Object.values(StreamType)) {\n\tNODES.set(streamType, new Node(streamType));\n}\n\n/**\n * Gets a node from its stream type\n *\n * @param type - The stream type of the target node\n */\nexport function getNode(type: StreamType) {\n\tconst node = NODES.get(type);\n\tif (!node) throw new Error(`Node type '${type}' does not exist!`);\n\treturn node;\n}\n\ngetNode(StreamType.Raw).addEdge({\n\ttype: TransformerType.OpusEncoder,\n\tto: getNode(StreamType.Opus),\n\tcost: 1.5,\n\ttransformer: () => new prism.opus.Encoder({ rate: 48000, channels: 2, frameSize: 960 }),\n});\n\ngetNode(StreamType.Opus).addEdge({\n\ttype: TransformerType.OpusDecoder,\n\tto: getNode(StreamType.Raw),\n\tcost: 1.5,\n\ttransformer: () => new prism.opus.Decoder({ rate: 48000, channels: 2, frameSize: 960 }),\n});\n\ngetNode(StreamType.OggOpus).addEdge({\n\ttype: TransformerType.OggOpusDemuxer,\n\tto: getNode(StreamType.Opus),\n\tcost: 1,\n\ttransformer: () => new prism.opus.OggDemuxer(),\n});\n\ngetNode(StreamType.WebmOpus).addEdge({\n\ttype: TransformerType.WebmOpusDemuxer,\n\tto: getNode(StreamType.Opus),\n\tcost: 1,\n\ttransformer: () => new prism.opus.WebmDemuxer(),\n});\n\nconst FFMPEG_PCM_EDGE: Omit<Edge, 'from'> = {\n\ttype: TransformerType.FFmpegPCM,\n\tto: getNode(StreamType.Raw),\n\tcost: 2,\n\ttransformer: (input) =>\n\t\tnew prism.FFmpeg({\n\t\t\targs: typeof input === 'string' ? ['-i', input, ...FFMPEG_PCM_ARGUMENTS] : FFMPEG_PCM_ARGUMENTS,\n\t\t}),\n};\n\ngetNode(StreamType.Arbitrary).addEdge(FFMPEG_PCM_EDGE);\ngetNode(StreamType.OggOpus).addEdge(FFMPEG_PCM_EDGE);\ngetNode(StreamType.WebmOpus).addEdge(FFMPEG_PCM_EDGE);\n\ngetNode(StreamType.Raw).addEdge({\n\ttype: TransformerType.InlineVolume,\n\tto: getNode(StreamType.Raw),\n\tcost: 0.5,\n\ttransformer: () => new prism.VolumeTransformer({ type: 's16le' }),\n});\n\n// Try to enable FFmpeg Ogg optimizations\nfunction canEnableFFmpegOptimizations(): boolean {\n\ttry {\n\t\treturn prism.FFmpeg.getInfo().output.includes('--enable-libopus');\n\t} catch {}\n\treturn false;\n}\n\nif (canEnableFFmpegOptimizations()) {\n\tconst FFMPEG_OGG_EDGE: Omit<Edge, 'from'> = {\n\t\ttype: TransformerType.FFmpegOgg,\n\t\tto: getNode(StreamType.OggOpus),\n\t\tcost: 2,\n\t\ttransformer: (input) =>\n\t\t\tnew prism.FFmpeg({\n\t\t\t\targs: typeof input === 'string' ? ['-i', input, ...FFMPEG_OPUS_ARGUMENTS] : FFMPEG_OPUS_ARGUMENTS,\n\t\t\t}),\n\t};\n\tgetNode(StreamType.Arbitrary).addEdge(FFMPEG_OGG_EDGE);\n\t// Include Ogg and WebM as well in case they have different sampling rates or are mono instead of stereo\n\t// at the moment, this will not do anything. However, if/when detection for correct Opus headers is\n\t// implemented, this will help inform the voice engine that it is able to transcode the audio.\n\tgetNode(StreamType.OggOpus).addEdge(FFMPEG_OGG_EDGE);\n\tgetNode(StreamType.WebmOpus).addEdge(FFMPEG_OGG_EDGE);\n}\n\n/**\n * Represents a step in the path from node A to node B.\n */\ninterface Step {\n\t/**\n\t * The next step\n\t */\n\tnext?: Step;\n\n\t/**\n\t * The cost of the steps after this step\n\t */\n\tcost: number;\n\n\t/**\n\t * The edge associated with this step\n\t */\n\tedge?: Edge;\n}\n\n/**\n * Finds the shortest cost path from node A to node B.\n *\n * @param from - The start node\n * @param constraints - Extra validation for a potential solution. Takes a path, returns true if the path is valid.\n * @param goal - The target node\n * @param path - The running path\n * @param depth - The number of remaining recursions\n */\nfunction findPath(\n\tfrom: Node,\n\tconstraints: (path: Edge[]) => boolean,\n\tgoal = getNode(StreamType.Opus),\n\tpath: Edge[] = [],\n\tdepth = 5,\n): Step {\n\tif (from === goal && constraints(path)) {\n\t\treturn { cost: 0 };\n\t} else if (depth === 0) {\n\t\treturn { cost: Infinity };\n\t}\n\n\tlet currentBest: Step | undefined = undefined;\n\tfor (const edge of from.edges) {\n\t\tif (currentBest && edge.cost > currentBest.cost) continue;\n\t\tconst next = findPath(edge.to, constraints, goal, [...path, edge], depth - 1);\n\t\tconst cost = edge.cost + next.cost;\n\t\tif (!currentBest || cost < currentBest.cost) {\n\t\t\tcurrentBest = { cost, edge, next };\n\t\t}\n\t}\n\treturn currentBest ?? { cost: Infinity };\n}\n\n/**\n * Takes the solution from findPath and assembles it into a list of edges\n *\n * @param step - The first step of the path\n */\nfunction constructPipeline(step: Step) {\n\tconst edges = [];\n\tlet current: Step | undefined = step;\n\twhile (current?.edge) {\n\t\tedges.push(current.edge);\n\t\tcurrent = current.next;\n\t}\n\treturn edges;\n}\n\n/**\n * Finds the lowest-cost pipeline to convert the input stream type into an Opus stream\n *\n * @param from - The stream type to start from\n * @param constraint - Extra constraints that may be imposed on potential solution\n */\nexport function findPipeline(from: StreamType, constraint: (path: Edge[]) => boolean) {\n\treturn constructPipeline(findPath(getNode(from), constraint));\n}\n"]}