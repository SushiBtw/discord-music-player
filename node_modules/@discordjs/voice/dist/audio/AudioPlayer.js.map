{"version":3,"file":"AudioPlayer.js","sourceRoot":"","sources":["../../src/audio/AudioPlayer.ts"],"names":[],"mappings":"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","sourcesContent":["import { addAudioPlayer, deleteAudioPlayer } from '../DataStore';\nimport { Awaited, noop } from '../util/util';\nimport { VoiceConnection, VoiceConnectionStatus } from '../VoiceConnection';\nimport { AudioPlayerError } from './AudioPlayerError';\nimport { AudioResource } from './AudioResource';\nimport { PlayerSubscription } from './PlayerSubscription';\nimport { TypedEmitter } from 'tiny-typed-emitter';\n\n// The Opus \"silent\" frame\nexport const SILENCE_FRAME = Buffer.from([0xf8, 0xff, 0xfe]);\n\n/**\n * Describes the behavior of the player when an audio packet is played but there are no available\n * voice connections to play to.\n */\nexport enum NoSubscriberBehavior {\n\t/**\n\t * Pauses playing the stream until a voice connection becomes available\n\t */\n\tPause = 'pause',\n\t/**\n\t * Continues to play through the resource regardless\n\t */\n\tPlay = 'play',\n\t/**\n\t * The player stops and enters the Idle state\n\t */\n\tStop = 'stop',\n}\n\nexport enum AudioPlayerStatus {\n\t/**\n\t * When there is currently no resource for the player to be playing\n\t */\n\tIdle = 'idle',\n\t/**\n\t * When the player is waiting for an audio resource to become readable before transitioning to Playing\n\t */\n\tBuffering = 'buffering',\n\t/**\n\t * When the player has been manually paused\n\t */\n\tPaused = 'paused',\n\t/**\n\t * When the player is actively playing an audio resource\n\t */\n\tPlaying = 'playing',\n\t/**\n\t * When the player has paused itself. Only possible with the \"pause\" no subscriber behavior.\n\t */\n\tAutoPaused = 'autopaused',\n}\n\n/**\n * Options that can be passed when creating an audio player, used to specify its behavior.\n */\nexport interface CreateAudioPlayerOptions {\n\tdebug?: boolean;\n\tbehaviors?: {\n\t\tnoSubscriber?: NoSubscriberBehavior;\n\t\tmaxMissedFrames?: number;\n\t};\n}\n\n/**\n * The state that an AudioPlayer is in when it has no resource to play. This is the starting state.\n */\nexport interface AudioPlayerIdleState {\n\tstatus: AudioPlayerStatus.Idle;\n}\n\n/**\n * The state that an AudioPlayer is in when it is waiting for a resource to become readable. Once this\n * happens, the AudioPlayer will enter the Playing state. If the resource ends/errors before this, then\n * it will re-enter the Idle state.\n */\nexport interface AudioPlayerBufferingState {\n\tstatus: AudioPlayerStatus.Buffering;\n\t/**\n\t * The resource that the AudioPlayer is waiting for\n\t */\n\tresource: AudioResource;\n\tonReadableCallback: () => void;\n\tonFailureCallback: () => void;\n\tonStreamError: (error: Error) => void;\n}\n\n/**\n * The state that an AudioPlayer is in when it is actively playing an AudioResource. When playback ends,\n * it will enter the Idle state.\n */\nexport interface AudioPlayerPlayingState {\n\tstatus: AudioPlayerStatus.Playing;\n\t/**\n\t * The number of consecutive times that the audio resource has been unable to provide an Opus frame.\n\t */\n\tmissedFrames: number;\n\t/**\n\t * The playback duration in milliseconds of the current audio resource. This includes filler silence packets\n\t * that have been played when the resource was buffering.\n\t */\n\tplaybackDuration: number;\n\t/**\n\t * The resource that is being played\n\t */\n\tresource: AudioResource;\n\tonStreamError: (error: Error) => void;\n}\n\n/**\n * The state that an AudioPlayer is in when it has either been explicitly paused by the user, or done\n * automatically by the AudioPlayer itself if there are no available subscribers.\n */\nexport interface AudioPlayerPausedState {\n\tstatus: AudioPlayerStatus.Paused | AudioPlayerStatus.AutoPaused;\n\t/**\n\t * How many silence packets still need to be played to avoid audio interpolation due to the stream suddenly pausing\n\t */\n\tsilencePacketsRemaining: number;\n\t/**\n\t * The playback duration in milliseconds of the current audio resource. This includes filler silence packets\n\t * that have been played when the resource was buffering.\n\t */\n\tplaybackDuration: number;\n\t/**\n\t * The current resource of the audio player\n\t */\n\tresource: AudioResource;\n\tonStreamError: (error: Error) => void;\n}\n\n/**\n * The various states that the player can be in.\n */\nexport type AudioPlayerState =\n\t| AudioPlayerIdleState\n\t| AudioPlayerBufferingState\n\t| AudioPlayerPlayingState\n\t| AudioPlayerPausedState;\n\nexport type AudioPlayerEvents = {\n\terror: (error: AudioPlayerError) => Awaited<void>;\n\tdebug: (message: string) => Awaited<void>;\n\tstateChange: (oldState: AudioPlayerState, newState: AudioPlayerState) => Awaited<void>;\n\tsubscribe: (subscription: PlayerSubscription) => Awaited<void>;\n\tunsubscribe: (subscription: PlayerSubscription) => Awaited<void>;\n} & {\n\t[status in AudioPlayerStatus]: (\n\t\toldState: AudioPlayerState,\n\t\tnewState: AudioPlayerState & { status: status },\n\t) => Awaited<void>;\n};\n\n/**\n * Used to play audio resources (i.e. tracks, streams) to voice connections.\n *\n * @remarks\n * Audio players are designed to be re-used - even if a resource has finished playing, the player itself\n * can still be used.\n *\n * The AudioPlayer drives the timing of playback, and therefore is unaffected by voice connections\n * becoming unavailable. Its behavior in these scenarios can be configured.\n */\nexport class AudioPlayer extends TypedEmitter<AudioPlayerEvents> {\n\t/**\n\t * The state that the AudioPlayer is in\n\t */\n\tprivate _state: AudioPlayerState;\n\n\t/**\n\t * A list of VoiceConnections that are registered to this AudioPlayer. The player will attempt to play audio\n\t * to the streams in this list.\n\t */\n\tprivate readonly subscribers: PlayerSubscription[] = [];\n\n\t/**\n\t * The behavior that the player should follow when it enters certain situations.\n\t */\n\tprivate readonly behaviors: {\n\t\tnoSubscriber: NoSubscriberBehavior;\n\t\tmaxMissedFrames: number;\n\t};\n\n\t/**\n\t * The debug logger function, if debugging is enabled.\n\t */\n\tprivate readonly debug: null | ((message: string) => void);\n\n\t/**\n\t * Creates a new AudioPlayer\n\t */\n\tpublic constructor(options: CreateAudioPlayerOptions = {}) {\n\t\tsuper();\n\t\tthis._state = { status: AudioPlayerStatus.Idle };\n\t\tthis.behaviors = {\n\t\t\tnoSubscriber: NoSubscriberBehavior.Pause,\n\t\t\tmaxMissedFrames: 5,\n\t\t\t...options.behaviors,\n\t\t};\n\t\tthis.debug = options.debug === false ? null : (message: string) => this.emit('debug', message);\n\t}\n\n\t/**\n\t * A list of subscribed voice connections that can currently receive audio to play\n\t */\n\tpublic get playable() {\n\t\treturn this.subscribers\n\t\t\t.filter(({ connection }) => connection.state.status === VoiceConnectionStatus.Ready)\n\t\t\t.map(({ connection }) => connection);\n\t}\n\n\t/**\n\t * Subscribes a VoiceConnection to the audio player's play list. If the VoiceConnection is already subscribed,\n\t * then the existing subscription is used.\n\t *\n\t * @remarks\n\t * This method should not be directly called. Instead, use VoiceConnection#subscribe.\n\t *\n\t * @param connection - The connection to subscribe\n\t * @returns The new subscription if the voice connection is not yet subscribed, otherwise the existing subscription.\n\t */\n\tprivate subscribe(connection: VoiceConnection) {\n\t\tconst existingSubscription = this.subscribers.find((subscription) => subscription.connection === connection);\n\t\tif (!existingSubscription) {\n\t\t\tconst subscription = new PlayerSubscription(connection, this);\n\t\t\tthis.subscribers.push(subscription);\n\t\t\tsetImmediate(() => this.emit('subscribe', subscription));\n\t\t\treturn subscription;\n\t\t}\n\t\treturn existingSubscription;\n\t}\n\n\t/**\n\t * Unsubscribes a subscription - i.e. removes a voice connection from the play list of the audio player.\n\t *\n\t * @remarks\n\t * This method should not be directly called. Instead, use PlayerSubscription#unsubscribe.\n\t *\n\t * @param subscription - The subscription to remove\n\t * @returns Whether or not the subscription existed on the player and was removed.\n\t */\n\tprivate unsubscribe(subscription: PlayerSubscription) {\n\t\tconst index = this.subscribers.indexOf(subscription);\n\t\tconst exists = index !== -1;\n\t\tif (exists) {\n\t\t\tthis.subscribers.splice(index, 1);\n\t\t\tsubscription.connection.setSpeaking(false);\n\t\t\tthis.emit('unsubscribe', subscription);\n\t\t}\n\t\treturn exists;\n\t}\n\n\t/**\n\t * The state that the player is in.\n\t */\n\tpublic get state() {\n\t\treturn this._state;\n\t}\n\n\t/**\n\t * Sets a new state for the player, performing clean-up operations where necessary.\n\t */\n\tpublic set state(newState: AudioPlayerState) {\n\t\tconst oldState = this._state;\n\t\tconst newResource = Reflect.get(newState, 'resource') as AudioResource | undefined;\n\n\t\tif (oldState.status !== AudioPlayerStatus.Idle && oldState.resource !== newResource) {\n\t\t\toldState.resource.playStream.on('error', noop);\n\t\t\toldState.resource.playStream.off('error', oldState.onStreamError);\n\t\t\toldState.resource.audioPlayer = undefined;\n\t\t\toldState.resource.playStream.destroy();\n\t\t\toldState.resource.playStream.read(); // required to ensure buffered data is drained, prevents memory leak\n\t\t}\n\n\t\t// When leaving the Buffering state (or buffering a new resource), then remove the event listeners from it\n\t\tif (\n\t\t\toldState.status === AudioPlayerStatus.Buffering &&\n\t\t\t(newState.status !== AudioPlayerStatus.Buffering || newState.resource !== oldState.resource)\n\t\t) {\n\t\t\toldState.resource.playStream.off('end', oldState.onFailureCallback);\n\t\t\toldState.resource.playStream.off('close', oldState.onFailureCallback);\n\t\t\toldState.resource.playStream.off('finish', oldState.onFailureCallback);\n\t\t\toldState.resource.playStream.off('readable', oldState.onReadableCallback);\n\t\t}\n\n\t\t// transitioning into an idle should ensure that connections stop speaking\n\t\tif (newState.status === AudioPlayerStatus.Idle) {\n\t\t\tthis._signalStopSpeaking();\n\t\t\tdeleteAudioPlayer(this);\n\t\t}\n\n\t\t// attach to the global audio player timer\n\t\tif (newResource) {\n\t\t\taddAudioPlayer(this);\n\t\t}\n\n\t\t// playing -> playing state changes should still transition if a resource changed (seems like it would be useful!)\n\t\tconst didChangeResources =\n\t\t\toldState.status !== AudioPlayerStatus.Idle &&\n\t\t\tnewState.status === AudioPlayerStatus.Playing &&\n\t\t\toldState.resource !== newState.resource;\n\n\t\tthis._state = newState;\n\n\t\tthis.emit('stateChange', oldState, this._state);\n\t\tif (oldState.status !== newState.status || didChangeResources) {\n\t\t\tthis.emit(newState.status, oldState, this._state as any);\n\t\t}\n\t\tthis.debug?.(`state change:\\nfrom ${stringifyState(oldState)}\\nto ${stringifyState(newState)}`);\n\t}\n\n\t/**\n\t * Plays a new resource on the player. If the player is already playing a resource, the existing resource is destroyed\n\t * (it cannot be reused, even in another player) and is replaced with the new resource.\n\t *\n\t * @remarks\n\t * The player will transition to the Playing state once playback begins, and will return to the Idle state once\n\t * playback is ended.\n\t *\n\t * If the player was previously playing a resource and this method is called, the player will not transition to the\n\t * Idle state during the swap over.\n\t *\n\t * @param resource - The resource to play\n\t * @throws Will throw if attempting to play an audio resource that has already ended, or is being played by another player.\n\t */\n\tpublic play<T>(resource: AudioResource<T>) {\n\t\tif (resource.ended) {\n\t\t\tthrow new Error('Cannot play a resource that has already ended.');\n\t\t}\n\n\t\tif (resource.audioPlayer) {\n\t\t\tif (resource.audioPlayer === this) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new Error('Resource is already being played by another audio player.');\n\t\t}\n\t\tresource.audioPlayer = this;\n\n\t\t// Attach error listeners to the stream that will propagate the error and then return to the Idle\n\t\t// state if the resource is still being used.\n\t\tconst onStreamError = (error: Error) => {\n\t\t\tif (this.state.status !== AudioPlayerStatus.Idle) {\n\t\t\t\t/**\n\t\t\t\t * Emitted when there is an error emitted from the audio resource played by the audio player\n\t\t\t\t *\n\t\t\t\t * @event AudioPlayer#error\n\t\t\t\t * @type {AudioPlayerError}\n\t\t\t\t */\n\t\t\t\tthis.emit('error', new AudioPlayerError(error, this.state.resource));\n\t\t\t}\n\n\t\t\tif (this.state.status !== AudioPlayerStatus.Idle && this.state.resource === resource) {\n\t\t\t\tthis.state = {\n\t\t\t\t\tstatus: AudioPlayerStatus.Idle,\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\tresource.playStream.once('error', onStreamError);\n\n\t\tif (resource.started) {\n\t\t\tthis.state = {\n\t\t\t\tstatus: AudioPlayerStatus.Playing,\n\t\t\t\tmissedFrames: 0,\n\t\t\t\tplaybackDuration: 0,\n\t\t\t\tresource,\n\t\t\t\tonStreamError,\n\t\t\t};\n\t\t} else {\n\t\t\tconst onReadableCallback = () => {\n\t\t\t\tif (this.state.status === AudioPlayerStatus.Buffering && this.state.resource === resource) {\n\t\t\t\t\tthis.state = {\n\t\t\t\t\t\tstatus: AudioPlayerStatus.Playing,\n\t\t\t\t\t\tmissedFrames: 0,\n\t\t\t\t\t\tplaybackDuration: 0,\n\t\t\t\t\t\tresource,\n\t\t\t\t\t\tonStreamError,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst onFailureCallback = () => {\n\t\t\t\tif (this.state.status === AudioPlayerStatus.Buffering && this.state.resource === resource) {\n\t\t\t\t\tthis.state = {\n\t\t\t\t\t\tstatus: AudioPlayerStatus.Idle,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tresource.playStream.once('readable', onReadableCallback);\n\n\t\t\tresource.playStream.once('end', onFailureCallback);\n\t\t\tresource.playStream.once('close', onFailureCallback);\n\t\t\tresource.playStream.once('finish', onFailureCallback);\n\n\t\t\tthis.state = {\n\t\t\t\tstatus: AudioPlayerStatus.Buffering,\n\t\t\t\tresource,\n\t\t\t\tonReadableCallback,\n\t\t\t\tonFailureCallback,\n\t\t\t\tonStreamError,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Pauses playback of the current resource, if any.\n\t *\n\t * @param interpolateSilence - If true, the player will play 5 packets of silence after pausing to prevent audio glitches.\n\t * @returns true if the player was successfully paused, otherwise false.\n\t */\n\tpublic pause(interpolateSilence = true) {\n\t\tif (this.state.status !== AudioPlayerStatus.Playing) return false;\n\t\tthis.state = {\n\t\t\t...this.state,\n\t\t\tstatus: AudioPlayerStatus.Paused,\n\t\t\tsilencePacketsRemaining: interpolateSilence ? 5 : 0,\n\t\t};\n\t\treturn true;\n\t}\n\n\t/**\n\t * Unpauses playback of the current resource, if any.\n\t *\n\t * @returns true if the player was successfully unpaused, otherwise false.\n\t */\n\tpublic unpause() {\n\t\tif (this.state.status !== AudioPlayerStatus.Paused) return false;\n\t\tthis.state = {\n\t\t\t...this.state,\n\t\t\tstatus: AudioPlayerStatus.Playing,\n\t\t\tmissedFrames: 0,\n\t\t};\n\t\treturn true;\n\t}\n\n\t/**\n\t * Stops playback of the current resource and destroys the resource. The player will either transition to the Idle state,\n\t * or remain in its current state until the silence padding frames of the resource have been played.\n\t *\n\t * @param force - If true, will force the player to enter the Idle state even if the resource has silence padding frames.\n\t * @returns true if the player will come to a stop, otherwise false.\n\t */\n\tpublic stop(force = false) {\n\t\tif (this.state.status === AudioPlayerStatus.Idle) return false;\n\t\tif (force || this.state.resource.silencePaddingFrames === 0) {\n\t\t\tthis.state = {\n\t\t\t\tstatus: AudioPlayerStatus.Idle,\n\t\t\t};\n\t\t} else if (this.state.resource.silenceRemaining === -1) {\n\t\t\tthis.state.resource.silenceRemaining = this.state.resource.silencePaddingFrames;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks whether the underlying resource (if any) is playable (readable).\n\t *\n\t * @returns true if the resource is playable, false otherwise.\n\t */\n\tpublic checkPlayable() {\n\t\tconst state = this._state;\n\t\tif (state.status === AudioPlayerStatus.Idle || state.status === AudioPlayerStatus.Buffering) return false;\n\n\t\t// If the stream has been destroyed or is no longer readable, then transition to the Idle state.\n\t\tif (!state.resource.readable) {\n\t\t\tthis.state = {\n\t\t\t\tstatus: AudioPlayerStatus.Idle,\n\t\t\t};\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Called roughly every 20ms by the global audio player timer. Dispatches any audio packets that are buffered\n\t * by the active connections of this audio player.\n\t */\n\tprivate _stepDispatch() {\n\t\tconst state = this._state;\n\n\t\t// Guard against the Idle state\n\t\tif (state.status === AudioPlayerStatus.Idle || state.status === AudioPlayerStatus.Buffering) return;\n\n\t\t// Dispatch any audio packets that were prepared in the previous cycle\n\t\tthis.playable.forEach((connection) => connection.dispatchAudio());\n\t}\n\n\t/**\n\t * Called roughly every 20ms by the global audio player timer. Attempts to read an audio packet from the\n\t * underlying resource of the stream, and then has all the active connections of the audio player prepare it\n\t * (encrypt it, append header data) so that it is ready to play at the start of the next cycle.\n\t */\n\tprivate _stepPrepare() {\n\t\tconst state = this._state;\n\n\t\t// Guard against the Idle state\n\t\tif (state.status === AudioPlayerStatus.Idle || state.status === AudioPlayerStatus.Buffering) return;\n\n\t\t// List of connections that can receive the packet\n\t\tconst playable = this.playable;\n\n\t\t/* If the player was previously in the AutoPaused state, check to see whether there are newly available\n\t\t   connections, allowing us to transition out of the AutoPaused state back into the Playing state */\n\t\tif (state.status === AudioPlayerStatus.AutoPaused && playable.length > 0) {\n\t\t\tthis.state = {\n\t\t\t\t...state,\n\t\t\t\tstatus: AudioPlayerStatus.Playing,\n\t\t\t\tmissedFrames: 0,\n\t\t\t};\n\t\t}\n\n\t\t/* If the player is (auto)paused, check to see whether silence packets should be played and\n\t\t   set a timeout to begin the next cycle, ending the current cycle here. */\n\t\tif (state.status === AudioPlayerStatus.Paused || state.status === AudioPlayerStatus.AutoPaused) {\n\t\t\tif (state.silencePacketsRemaining > 0) {\n\t\t\t\tstate.silencePacketsRemaining--;\n\t\t\t\tthis._preparePacket(SILENCE_FRAME, playable, state);\n\t\t\t\tif (state.silencePacketsRemaining === 0) {\n\t\t\t\t\tthis._signalStopSpeaking();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are no available connections in this cycle, observe the configured \"no subscriber\" behavior.\n\t\tif (playable.length === 0) {\n\t\t\tif (this.behaviors.noSubscriber === NoSubscriberBehavior.Pause) {\n\t\t\t\tthis.state = {\n\t\t\t\t\t...state,\n\t\t\t\t\tstatus: AudioPlayerStatus.AutoPaused,\n\t\t\t\t\tsilencePacketsRemaining: 5,\n\t\t\t\t};\n\t\t\t\treturn;\n\t\t\t} else if (this.behaviors.noSubscriber === NoSubscriberBehavior.Stop) {\n\t\t\t\tthis.stop(true);\n\t\t\t}\n\t\t}\n\n\t\t/* Attempt to read an Opus packet from the resource. If there isn't an available packet,\n\t\t\t play a silence packet. If there are 5 consecutive cycles with failed reads, then the\n\t\t\t playback will end. */\n\t\tconst packet: Buffer | null = state.resource.read();\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\t\tif (state.status === AudioPlayerStatus.Playing) {\n\t\t\tif (packet) {\n\t\t\t\tthis._preparePacket(packet, playable, state);\n\t\t\t\tstate.missedFrames = 0;\n\t\t\t} else {\n\t\t\t\tthis._preparePacket(SILENCE_FRAME, playable, state);\n\t\t\t\tstate.missedFrames++;\n\t\t\t\tif (state.missedFrames >= this.behaviors.maxMissedFrames) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Signals to all the subscribed connections that they should send a packet to Discord indicating\n\t * they are no longer speaking. Called once playback of a resource ends.\n\t */\n\tprivate _signalStopSpeaking() {\n\t\treturn this.subscribers.forEach(({ connection }) => connection.setSpeaking(false));\n\t}\n\n\t/**\n\t * Instructs the given connections to each prepare this packet to be played at the start of the\n\t * next cycle.\n\t *\n\t * @param packet - The Opus packet to be prepared by each receiver\n\t * @param receivers - The connections that should play this packet\n\t */\n\tprivate _preparePacket(\n\t\tpacket: Buffer,\n\t\treceivers: VoiceConnection[],\n\t\tstate: AudioPlayerPlayingState | AudioPlayerPausedState,\n\t) {\n\t\tstate.playbackDuration += 20;\n\t\treceivers.forEach((connection) => connection.prepareAudioPacket(packet));\n\t}\n}\n\n/**\n * Stringifies an AudioPlayerState instance\n *\n * @param state - The state to stringify\n */\nfunction stringifyState(state: AudioPlayerState) {\n\treturn JSON.stringify({\n\t\t...state,\n\t\tresource: Reflect.has(state, 'resource'),\n\t\tstepTimeout: Reflect.has(state, 'stepTimeout'),\n\t});\n}\n\n/**\n * Creates a new AudioPlayer to be used\n */\nexport function createAudioPlayer(options?: CreateAudioPlayerOptions) {\n\treturn new AudioPlayer(options);\n}\n"]}